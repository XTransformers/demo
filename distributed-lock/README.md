
[TOC]

## 分布式锁产生背景

分布式、集群部署的方式虽然给企业级应用系统带来性能和效率上的提升，给企业业务带来可扩展的收益，但也由此带来了一些棘手的问题，其中比较典型的问题是高并发场景下多个线程并发访问、操作共享资源时，出现数据不一致的现象。业界普遍采取“分布式锁”加以解决。

传统单体应用，通过**加同步互斥锁**的机制，控制并发访问、操作共享资源。

分布式系统架构部署方案的落地，使得传统加锁的方式不再起作用，因为分布式系统架构下资源共享是跨 JVM 进程之间的共享。

共享资源，指的是可以被多个线程、进程同时访问，并进行操作的数据或者代码块。

分布式锁，也是一种锁机制，一种实现方式，一种解决方案。在分布式部署环境下，通过锁机制，让多个客户端或者多个服务进程互斥地对共享资源进行访问，从而避免出现并发安全、数据不一致等问题。

## 分布式锁要求

对于分布式锁的设计和使用，业界普遍几点要求：

- 排他性：保证在分布式部署、服务集群的环境下，共享的资源在同一时刻只能被一台机器上的一个线程执行
- 避免死锁：锁被获取后，经过一段有限的时间，一定要被释放
- 高可用：获取或释放锁的机制必须高可用，并且性能极佳
- 可重入：在一个线程中可以多次获取同一把锁
- 公平锁：保证来自不同机器的并发线程都可以获取到锁

## 分布式锁实现方式

实现分布式锁常见几种方式：

- 基于数据库级别的锁
  - 乐观锁
    - 在查询、操作共享数据记录时带上一个标识字段 version，通过 version 来控制每次对数据记录执行的更新操作
  - 悲观锁
    - MySQL 的 InnoDB 引擎，通过在查询共享数据记录时加上 for update，标识共享数据已经被当前线程锁住了，只有该线程操作完成并提交事务后，才会释放该锁
- 基于 Redis 的原子操作
  - 通过 Redis 提供的 SETNX 和 EXPIRE 来实现
- 基于 Zookeeper 的互斥排他锁
  - 通过 ZK 在指定的标识字符串下维护一个临时有序的节点列表，并保证同一时刻并发线程访问共享资源时只能有一个最小序号的节点
- 基于开源框架 Redisson 的分布式锁

## 代码实战

重复提交场景：模拟用户注册重复提交；

数据库表设计

```mysql
CREATE TABLE `user_reg` (
  `id` int(11) NOT NULL AUTO_INCREMENT,  
  `user_name` varchar(255) NOT NULL COMMENT '用户名',  
  `password` varchar(255) NOT NULL COMMENT '密码',  
  `create_time` datetime DEFAULT NULL COMMENT '创建时间', 
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='用户注册信息表';
```

### 1.基于 Redis 实现

核心：

- 精心设计构造一个跟共享资源或核心业务相关的 key
- 调用 SETNX 和 EXPIRE 操作加锁
- 调用 DEL 操作释放锁

是否使用分布式锁，在 UserRegController 有 2 个接口（”/user/reg/submit“ 和 ”/user/reg/submit-withlock”），对应到底层是 UserRegService 中的 userRegNoLock 和 userRegWithLock 方法。

使用 JMeter 高并发测试，配置详见”高并发测试-基于Redis.jmx“。



### 2.基于 Zookeeper 实现

基于 ZK 的临时节点和 Watcher 机制实现的分布式锁。

在 ZK 中，数据模型中的数据单元，称之为数据节点，即 ZNode。

- 持久节点
  - 一旦这个 ZNode 被创建了，除非主动移除，否则会一致保存在 ZK 上。
- 临时节点
  - 生命周期和客户端的会话绑定在一起的，一旦客户端会话失效，那么这个客户端创建的所有临时节点都会被移除。































